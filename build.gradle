import java.net.InetAddress;

plugins {
	id "java"
	id "com.diffplug.spotless" version "6.15.0"
	id "edu.wpi.first.GradleRIO" version "2023.4.3"
	id "net.ltgt.errorprone"
}

repositories {
	mavenCentral()
	maven { url "https://jitpack.io" }
}

sourceCompatibility = JavaVersion.VERSION_11
targetCompatibility = JavaVersion.VERSION_11

def getProjectBooleanProperty(String name, boolean defaultValue = false) {
	if (!project.hasProperty(name)) {
		return defaultValue
	}
	// Note that this is equivalent to 'true'.equalsIgnoreCase(project.getProperty(name))
	// Values that are not "true" or "false" (including null) are treated as false
	return Boolean.parseBoolean(project.getProperty(name))
}

def ROBOT_MAIN_CLASS = getProjectBooleanProperty('automatedTest') ? "frc.team2412.robot.test.AutomatedTestMain" : "frc.team2412.robot.Main"

// Define my targets (RoboRIO) and artifacts (deployable files)
// This is added by GradleRIO's backing project DeployUtils.
deploy {
	targets {
		roborio(getTargetTypeClass("RoboRIO")) {
			// Team number is loaded either from the .wpilib/wpilib_preferences.json
			// or from command line. If not found an exception will be thrown.
			// You can use getTeamOrDefault(team) instead of getTeamNumber if you
			// want to store a team number in this file.
			team = project.frc.getTeamNumber()
			debug = project.frc.getDebugOrDefault(false)

			artifacts {
				// First part is artifact name, 2nd is artifact type
				// getTargetTypeClass is a shortcut to get the class type using a string

				frcJava(getArtifactTypeClass("FRCJavaArtifact")) {
				}

				// Static files artifact
				frcStaticFileDeploy(getArtifactTypeClass("FileTreeArtifact")) {
					files = project.fileTree("src/main/deploy")
					directory = "/home/lvuser/deploy"
				}
			}
		}
	}
}

def deployArtifact = deploy.targets.roborio.artifacts.frcJava

// Set to true to use debug for JNI.
wpi.java.debugJni = false

// Set this to true to enable desktop support.
def includeDesktopSupport = true

// Defining my dependencies. In this case, WPILib (+ friends), and vendor libraries.
// Also defines JUnit 4.
dependencies {
	implementation 'org.jetbrains:annotations:19.0.0'
	compileOnly group: "com.google.errorprone", name: "error_prone_annotations", version: "2.10.0"

	implementation wpi.java.deps.wpilib()
	implementation wpi.java.vendor.java()

	roborioDebug wpi.java.deps.wpilibJniDebug(wpi.platforms.roborio)
	roborioDebug wpi.java.vendor.jniDebug(wpi.platforms.roborio)

	roborioRelease wpi.java.deps.wpilibJniRelease(wpi.platforms.roborio)
	roborioRelease wpi.java.vendor.jniRelease(wpi.platforms.roborio)

	nativeDebug wpi.java.deps.wpilibJniDebug(wpi.platforms.desktop)
	nativeDebug wpi.java.vendor.jniDebug(wpi.platforms.desktop)
	simulationDebug wpi.sim.enableDebug()

	nativeRelease wpi.java.deps.wpilibJniRelease(wpi.platforms.desktop)
	nativeRelease wpi.java.vendor.jniRelease(wpi.platforms.desktop)
	simulationRelease wpi.sim.enableRelease()

	testImplementation "junit:junit:4.12"

	errorprone group: "com.google.errorprone", name: "error_prone_core", version: "2.10.0"
}

tasks.withType(JavaCompile).configureEach {
	options.errorprone.disableWarningsInGeneratedCode = true
}

// Simulation configuration (e.g. environment variables).

if (!getProjectBooleanProperty('automatedTest')) {
	wpi.sim.addGui().defaultEnabled = true
	wpi.sim.addDriverstation()
}

// Setting up my Jar File. In this case, adding all libraries into the main jar ("fat jar")
// in order to make them all available at runtime. Also adding the manifest so WPILib
// knows where to look for our Robot Class.
jar {
	from { configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) } }
	manifest edu.wpi.first.gradlerio.GradleRIOPlugin.javaManifest(ROBOT_MAIN_CLASS)
	duplicatesStrategy = DuplicatesStrategy.INCLUDE
}

// Configure jar and deploy tasks
deployArtifact.jarTask = jar
wpi.java.configureExecutableTasks(jar)
wpi.java.configureTestTasks(test)

// Spotless
spotless {
	format "misc", {
		target "*"
		targetExclude "simgui*.json", "**/build/**", "**/build-*/**", "**/bin/**", "/.*"
		toggleOffOn()
		indentWithTabs()
		endWithNewline()
		trimTrailingWhitespace()
	}

	java {
		importOrder();
		googleJavaFormat();
		toggleOffOn();
		indentWithTabs(2);
		endWithNewline();
		trimTrailingWhitespace();
	}
}

task writeGitInfo {
	def hasGit = { ->
		try {
			exec {
				executable 'git'
				delegate.args '--version'
				standardOutput = OutputStream.nullOutputStream()
			}
		} catch (Exception e) {
			return false
		}
		return true
	}

	def addGitOutput = { PrintStream output, String name, String... args ->
		output.println("### $name (git ${String.join(' ', args)})")
		// Temporary stream so that we don't close output
		def execOutput = new ByteArrayOutputStream()
		def ex = exec {
			workingDir projectDir
			executable 'git'
			delegate.args args
			standardOutput = execOutput
		}
		output.print(execOutput)
	}

	def convertPath = { String path ->
		String username = System.getenv("USERNAME")
		if (username != null) {
			return path.replace(username, "\$USERNAME")
		}
		return path
	}

	doLast {
		try (PrintStream output = new PrintStream('src/main/deploy/git-info.txt')) {
			output.println("### Host name (InetAddress.localHost.hostName)")
			output.println(InetAddress.localHost.hostName)
			output.println("### Project path (convertPath(projectDir.path))")
			output.println(convertPath(projectDir.path))
			if (!hasGit()) {
				// ANSI escape codes
				def WARNINGFMT = "\033[43;30m"
				def CLEAR = "\033[m"
				println("${WARNINGFMT}WARNING: Could not find git! Git info will not be sent to the robot.${CLEAR}")
				output.println("### <could not run git>")
			} else {
				addGitOutput(output, 'Commit hash', 'log', '-1', '--format=%H')
				addGitOutput(output, 'Refs to latest commit', 'log', '-1', '--format=%D')
				addGitOutput(output, 'Commit date', 'log', '-1', '--format=%ad')
				addGitOutput(output, 'Commit message', 'log', '-1', '--format=%B')
				addGitOutput(output, 'Remotes', 'remote', '-v')
				addGitOutput(output, 'Changed files', 'diff-index', '--name-only', 'HEAD', '--')
				addGitOutput(output, 'Untracked files', 'ls-files', '--exclude-standard', '--others')
			}
			output.println('### (END)')
		}
	}
}
if (getProjectBooleanProperty('jarWriteGitInfo', true)) {
	jar.dependsOn(writeGitInfo)
}

// Set up spotless
tasks.named("build") { finalizedBy("spotlessApply") }
tasks.named("deploy") { finalizedBy("spotlessApply") }
spotlessCheck.mustRunAfter(compileJava);
